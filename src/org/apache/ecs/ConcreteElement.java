/*
 * Copyright 1999-2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.ecs;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StreamCorruptedException;
import java.io.Writer;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

/**
 * This class is to be subclassed by those elements that are made up of other elements. i.e. BODY,HEAD,etc.
 * 
 * @version $Id: ConcreteElement.java,v 1.9 2011/03/13 04:30:13 bleujin Exp $
 * @author <a href="mailto:snagy@servletapi.com">Stephan Nagy</a>
 * @author <a href="mailto:jon@clearink.com">Jon S. Stevens</a>
 */
public class ConcreteElement extends ElementAttributes implements Cloneable {
	/** The line separator to use for pretty printing */
	private static String lineSeparator = System.getProperty("line.separator");

	/** @serial registry registry */
	private Hashtable registry; // keep a list of elements that need to be added to the element
	/** Maintain an ordered list of elements */
	private Vector registryList = new Vector(2);

	public ConcreteElement() {
	}

	private static final String HASHCODE_AUTOGENERATED = "org.apache.ecs.#@HcAg@#";

	/**
	 * Utility to test for autogenerated key names
	 * 
	 * @param the
	 *            key as given by the keys() enumeration.
	 */
	private boolean isAutoGenerated(String name) {
		return (name != null) && name.startsWith(HASHCODE_AUTOGENERATED);
	}

	/**
	 * Utility to search for elements with autogenerated keys in the registryList
	 * 
	 * @param the
	 *            key as given by the keys() enumeration.
	 */

	private ConcreteElement searchAutoGenerated(String name) {
		int hashcode = Integer.parseInt(name.substring(HASHCODE_AUTOGENERATED.length()));
		Object o;
		for (int i = 0; i < registryList.size(); i++) {
			o = registryList.get(i);
			if (o != null && o.hashCode() == hashcode)
				return (ConcreteElement) o;
		}
		return null;
	}

	/**
	 * If the object is in the registry return otherwise return null.
	 * 
	 * @param element
	 *            the name of the object to locate.
	 */
	public ConcreteElement getElement(String name) {
		if (isAutoGenerated(name)) {
			return searchAutoGenerated(name);
		} else {
			if (registry == null)
				return null;
			return (ConcreteElement) registry.get(name);
		}
	}

	/**
	 * Registers an element in the head element list
	 * 
	 * @param element
	 *            element to be added to the registry.
	 */
	public Element addElementToRegistry(Element element) {
		if (element == null)
			return (this);
		addElementToRegistry(null, element);
		return (this);
	}

	/**
	 * Registers an element in the head element list
	 * 
	 * @param hashcode
	 *            internal name of element
	 * @param element
	 *            element to be added to the registry.
	 */
	public Element addElementToRegistry(String name, Element element) {
		if (element == null)
			return (this);

		element.setFilterState(getFilterState());
		if (ECSDefaults.getDefaultPrettyPrint() != element.getPrettyPrint())
			element.setPrettyPrint(getPrettyPrint());
		if (name != null) {
			if (registry == null)
				registry = new Hashtable(4);
			registry.put(name, element);
		}
		if (!registryList.contains(element))
			registryList.addElement(element);
		return (this);
	}

	/**
	 * Registers an element in the head element list
	 * 
	 * @hashcode named element for hashcode
	 * @param element
	 *            element to be added to the registry.
	 * @param filter
	 *            does this need to be filtered?
	 */
	public Element addElementToRegistry(Element element, boolean filter) {
		if (element == null)
			return (this);
		setFilterState(filter);
		addElementToRegistry(null, element);
		return (this);
	}

	/**
	 * Registers an element in the head element list
	 * 
	 * @param element
	 *            element to be added to the registry.
	 * @param filter
	 *            should we filter this element?
	 */
	public Element addElementToRegistry(String name, Element element, boolean filter) {
		if (name == null)
			return (this);
		setFilterState(filter);
		addElementToRegistry(name, element);
		return (this);
	}

	/**
	 * Registers an element in the head element list
	 * 
	 * @param element
	 *            element to be added to the registry.
	 * @param filter
	 *            does this need to be filtered?
	 */
	public Element addElementToRegistry(String value, boolean filter) {
		if (value == null)
			return (this);
		setFilterState(filter);
		addElementToRegistry(value);
		return (this);
	}

	/**
	 * Registers an element in the head element list
	 * 
	 * @hashcode named element for hashcode
	 * @param element
	 *            element to be added to the registry.
	 * @param filter
	 *            does this need to be filtered?
	 */
	public Element addElementToRegistry(String name, String value, boolean filter) {
		if (name == null)
			return (this);
		setFilterState(filter);
		addElementToRegistry(name, value);
		return (this);
	}

	/**
	 * Registers an element in the head element list
	 * 
	 * @param element
	 *            element to be added to the registry.
	 */
	public Element addElementToRegistry(String value) {
		if (value == null)
			return (this);
		addElementToRegistry(new StringElement(value));
		return (this);
	}

	/**
	 * Registers an element in the head element list
	 * 
	 * @param element
	 *            element to be added to the registry.
	 */
	public Element addElementToRegistry(String name, String value) {
		if (name == null)
			return (this);

		// We do it this way so that filtering will work.
		// 1. create a new StringElement(element) - this is the only way that setTextTag will get called
		// 2. copy the filter state of this string element to this child.
		// 3. copy the prettyPrint state of the element to this child
		// 4. copy the filter for this string element to this child.

		StringElement se = new StringElement(value);
		se.setFilterState(getFilterState());
		se.setFilter(getFilter());
		se.setPrettyPrint(getPrettyPrint());
		addElementToRegistry(name, se);
		return (this);
	}

	/**
	 * Removes an element from the element registry
	 * 
	 * @param element
	 *            element to be added to the registry.
	 */
	public Element removeElementFromRegistry(Element element) {
		boolean contained = registryList.remove(element);
		if (contained && registry != null) {
			java.util.Iterator i = registry.entrySet().iterator();
			java.util.Map.Entry me;
			while (i.hasNext()) {
				me = (java.util.Map.Entry) i.next();
				if (element == me.getValue()) {
					registry.remove(me.getKey());
				}
			}
		}
		return (this);
	}

	/**
	 * Removes an element from the head element registry
	 * 
	 * @param hashcode
	 *            element to be added to the registry.
	 */
	public Element removeElementFromRegistry(String name) {
		if (isAutoGenerated(name)) {
			Object o = searchAutoGenerated(name);
			if (o != null)
				registryList.remove(o);
		} else {
			if (registry == null)
				return this;
			Object o = registry.remove(name);
			if (o != null)
				registryList.removeElement(o);
		}
		return (this);
	}

	/**
	 * Find out if this element is in the element registry.
	 * 
	 * @param element
	 *            find out if this element is in the registry
	 */
	public boolean registryHasElement(Element element) {
		return (registryList.contains(element));
	}

	/**
	 * Get the keys of this element.
	 * 
	 * @deprecated
	 */
	public Enumeration keys() {
		Vector v = new Vector(registryList.size());
		for (int j = 0; j < registryList.size(); j++) {
			v.add(HASHCODE_AUTOGENERATED + registryList.get(j).hashCode());
		}
		if (registry != null) {
			java.util.Iterator i = registry.entrySet().iterator();
			while (i.hasNext()) {
				java.util.Map.Entry me = (java.util.Map.Entry) i.next();
				int j = registryList.indexOf(me.getValue());
				if (j >= 0)
					v.set(j, me.getKey());
			}
		}
		return v.elements();
	}

	/**
	 * Get an enumeration of the elements that this element contains.
	 */
	public Enumeration elements() {
		return (registryList.elements());
	}

	/**
	 * Find out if this element is in the element registry.
	 * 
	 * @param element
	 *            find out if this element is in the registry
	 */
	public boolean registryHasElement(String name) {
		if (isAutoGenerated(name)) {
			Object o = searchAutoGenerated(name);
			return o != null;
		} else {
			if (registry == null)
				return false;
			return (registry.containsKey(name));
		}
	}

	/**
	 * Overload output(OutputStream).
	 * 
	 * @param output
	 *            OutputStream to write to.
	 * @param ConcreteElement
	 *            Instance of ConcreteElement
	 */
	public static void output(OutputStream out, ConcreteElement ce) {
		// use the encoding for the given element
		String encoding = ce.getCodeSet();
		if (encoding == null) {
			// By default use Big Endian Unicode.
			// In this way we will not loose any information.
			encoding = "UTF-16BE";
		}

		boolean prettyPrint = ce.getPrettyPrint();
		int tabLevel = ce.getTabLevel();
		try {
			if (ce.registryList.size() == 0) {
				ce.output(out);
			} else {
				if ((prettyPrint && ce instanceof Printable) && (tabLevel > 0))
					ce.putTabs(tabLevel, out);

				out.write(ce.createStartTag().getBytes(encoding));

				// If this is a StringElement that has ChildElements still print the TagText
				if (ce.getTagText() != null)
					out.write(ce.getTagText().getBytes(encoding));

				Enumeration enum_ = ce.registryList.elements();

				while (enum_.hasMoreElements()) {
					Object obj = (Object) enum_.nextElement();
					if (obj instanceof GenericElement) {
						Element e = (Element) obj;
						if (prettyPrint && ce instanceof Printable) {
							if (ce.getNeedLineBreak()) {
								out.write(ce.lineSeparator.getBytes(encoding));
								e.setTabLevel(tabLevel + 1);
							}
						}
						e.output(out);
					} else {
						if (prettyPrint && ce instanceof Printable) {
							if (ce.getNeedLineBreak()) {
								out.write(ce.lineSeparator.getBytes(encoding));
								ce.putTabs(tabLevel + 1, out);
							}
						}
						String string = obj.toString();
						out.write(string.getBytes(encoding));
					}
				}
				if (ce.getNeedClosingTag()) {
					if (prettyPrint && ce instanceof Printable) {
						if (ce.getNeedLineBreak()) {
							out.write(ce.lineSeparator.getBytes(encoding));
							if (tabLevel > 0)
								ce.putTabs(tabLevel, out);
						}
					}
					out.write(ce.createEndTag().getBytes(encoding));
				}
			}
		} catch (IOException ioe) {
			ioe.printStackTrace(new PrintWriter(out));
		}
	}

	/**
	 * Override output(OutputStream) incase any elements are in the registry.
	 * 
	 * @param output
	 *            OutputStream to write to.
	 */
	public void output(OutputStream out) {
		if (this.registryList.size() == 0) {
			int tabLevel = getTabLevel();
			if ((getPrettyPrint() && this instanceof Printable) && (tabLevel > 0)) {
				try {
					this.putTabs(tabLevel, out);
				} catch (IOException ioe) {
					ioe.printStackTrace(new PrintWriter(out));
				}
			}
			super.output(out);
		} else {
			output(out, this);
		}
	}

	/**
	 * Writer version of this method.
	 */
	public void output(Writer out) {
		PrintWriter pw = new PrintWriter(out);
		output(pw);
		pw.flush();
	}

	/**
	 * Override output(BufferedWriter) incase any elements are in the registry.
	 * 
	 * @param output
	 *            OutputStream to write to.
	 */
	public void output(PrintWriter out) {
		boolean prettyPrint = getPrettyPrint();
		int tabLevel = getTabLevel();
		if (registryList.size() == 0) {
			if ((prettyPrint && this instanceof Printable) && (tabLevel > 0))
				putTabs(tabLevel, out);

			super.output(out);
		} else {
			if ((prettyPrint && this instanceof Printable) && (tabLevel > 0))
				putTabs(tabLevel, out);

			out.write(createStartTag());
			// If this is a StringElement that has ChildElements still print the TagText
			if (getTagText() != null)
				out.write(getTagText());

			Enumeration enum_ = registryList.elements();
			while (enum_.hasMoreElements()) {
				Object obj = (Object) enum_.nextElement();
				if (obj instanceof GenericElement) {
					Element e = (Element) obj;
					if (prettyPrint && this instanceof Printable) {
						if (getNeedLineBreak()) {
							out.write(lineSeparator);
							e.setTabLevel(tabLevel + 1);
						}
					}
					e.output(out);
				} else {
					if (prettyPrint && this instanceof Printable) {
						if (getNeedLineBreak()) {
							out.write(lineSeparator);
							putTabs(tabLevel + 1, out);
						}
					}
					String string = obj.toString();
					if (getFilterState())
						out.write(getFilter().process(string));
					else
						out.write(string);
				}
			}
			if (getNeedClosingTag()) {
				if (prettyPrint && this instanceof Printable) {
					if (getNeedLineBreak()) {
						out.write(lineSeparator);
						if (tabLevel > 0)
							putTabs(tabLevel, out);
					}
				}
				out.write(createEndTag());
			}
		}
	}

	/**
	 * Allows all Elements the ability to be cloned.
	 */
	public Object clone() {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			ObjectOutputStream out = new ObjectOutputStream(baos);
			out.writeObject(this);
			out.close();
			ByteArrayInputStream bin = new ByteArrayInputStream(baos.toByteArray());
			ObjectInputStream in = new ObjectInputStream(bin);
			Object clone = in.readObject();
			in.close();
			return (clone);
		} catch (ClassNotFoundException cnfe) {
			throw new InternalError(cnfe.toString());
		} catch (StreamCorruptedException sce) {
			throw new InternalError(sce.toString());
		} catch (IOException ioe) {
			throw new InternalError(ioe.toString());
		}
	}

	public boolean isEmpty() {
		return registryList.isEmpty();
	}

}
